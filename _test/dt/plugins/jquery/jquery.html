<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Plugin: jquery</title>
	<meta name="tags" content="editor,unit,jquery">
	<script type="text/javascript" src="../../../cktester/cell.js"></script>
	<script type="text/javascript">
	//<![CDATA[

// Load the required plugins and launch the runner.
CKEDITOR.test.fort.defer = true;

$( window ).bind( 'load', function()
{
	CKEDITOR.plugins.load( 'jquery' , function()
	{
		CKEDITOR.test.fort.run();
	} );
} );

CKEDITOR.test.addTestCase( ( function()
{
	// Local references.
	var assert = CKEDITOR.test.assert,
		doc = CKEDITOR.document,
		action = YAHOO.util.UserAction,
		selector = YAHOO.util.Selector;

	function cleanup( id )
	{
		var instance = jQuery( '#' + id ).ckeditorGet();
		if ( instance )
			instance.destroy();
	}

	// Maximum time per each test. If test will take longer, failure will be thrown.
	var testTimeout = 10000;

	jQuery( 'textarea, input' ).val( 'default' );

	return {
		test_create : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery( 'textarea#create' ).ckeditor( function( textarea )
			{
				var editor = this;
				testSelf.resume( function()
				{
					assert.isTrue( editor instanceof CKEDITOR.editor, 'editor instanceof CKEDITOR.editor' );
					testFinished = true;
					cleanup( 'create' );
				});
			});
			testSelf.wait( function() {
				cleanup( 'create' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout + 5000);
		},

		test_config : function()
		{
			var testSelf = this,
				testFinished = false;
			CKEDITOR.config.test_config = false;
			jQuery( 'textarea#config' ).ckeditor(
				{ test_config: true },
				function( textarea )
				{
					var editor = this;
					testSelf.resume( function()
					{
						assert.isTrue( editor.config.test_config );
						testFinished = true;
						cleanup( 'config' );
					});
				}
			);
			testSelf.wait(function(){
				cleanup( 'config' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_config_no_order : function()
		{
			var testSelf = this,
				testFinished = false;
			CKEDITOR.config.test_config_no_order = false;
			jQuery('textarea#config_no_order').ckeditor(
				function( textarea )
				{
					var editor = this;
					testSelf.resume( function()
					{
						assert.isTrue( editor.config.test_config_no_order );
						testFinished = true;
						cleanup( 'config_no_order' );
					});
				},
				{ test_config_no_order: true }
			);
			testSelf.wait(function(){
				cleanup( 'config_no_order' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_config_global : function()
		{
			CKEDITOR.config.test_config_global = false;
			$.ckeditorConfig( { test_config_global: true } );
			assert.isTrue( CKEDITOR.config.test_config_global );
		},

		test_val_get_without_timeout : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery('textarea#val_get_without_timeout').ckeditor(function( textarea )
			{
				var editor = this;
				editor.dataProcessor.writer._.rules = {};
				testSelf.resume( function()
				{
					// editor.setData is async, which creates the test failure
					editor.setData( 'foo bar' );
					assert.areSame( '<p>foo bar</p>', jQuery( textarea ).val() );
					testFinished = true;
					cleanup( 'val_get_without_timeout' );
				});
			});
			testSelf.wait( function() {
				cleanup( 'val_get_without_timeout' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_val_get_with_timeout : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery('textarea#val_get_with_timeout').ckeditor(function( textarea )
			{
				var editor = this;
				editor.dataProcessor.writer._.rules = {};
				editor.setData( 'foo bar' );
				setTimeout(function()
				{
					testSelf.resume( function()
					{
						assert.areSame( '<p>foo bar</p>', jQuery( textarea ).val() );
						testFinished = true;
						cleanup( 'val_get_with_timeout' );
					});
				}, 1000);
			});
			testSelf.wait( function() {
				cleanup( 'val_get_with_timeout' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_val_set_with_timeout : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery('textarea#val_set_with_timeout').ckeditor(function( textarea )
			{
				var editor = this;
				editor.dataProcessor.writer._.rules = {};
				jQuery( textarea ).val( 'foo bar' );
				setTimeout( function()
				{
					testSelf.resume( function()
					{
						assert.areSame( '<p>foo bar</p>', editor.getData() );
						testFinished = true;
						cleanup( 'val_set_with_timeout' );
					});
				}, 1000);
			});
			testSelf.wait( function() {
				cleanup( 'val_set_with_timeout' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_ckeditor_get : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery('#ckeditor_get').ckeditor(function( textarea )
			{
				var editor = this;
				editor.dataProcessor.writer._.rules = {};
				editor.setData( 'foo bar' );
				setTimeout(function()
				{
					testSelf.resume( function()
					{
						var editor = jQuery( textarea ).ckeditorGet();
						assert.isObject( editor );
						testFinished = true;
						cleanup( 'ckeditor_get' );
					});
				// longer timeout may be needed
				}, 1000);
			});
			testSelf.wait( function() {
				cleanup( 'ckeditor_get' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_destroy : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery('textarea#destroy').ckeditor(function( textarea )
			{
				var editor = this;
				try
				{
					editor.destroy();
				}
				catch (e){}
				setTimeout(function()
				{
					testSelf.resume( function()
					{
							assert.isUndefined( CKEDITOR.instances.destroy );
							testFinished = true;
					});
				}, 0);
			});
			testSelf.wait(function(){
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_val_input_get : function()
		{
			assert.areSame( 'default', jQuery( '#val_input_get' ).val() );
		},

		test_val_input_set : function()
		{
			jQuery( '#val_input_set' ).val( 'new' );
			assert.areSame( 'new', jQuery('#val_input_set').get( 0 ).value );
		},

		test_submit : function()
		{
			var testSelf = this,
				testFinished = false;
			// Synchronize textarea content on form submit
			jQuery( '#submit textarea' ).ckeditor(
				{ jquerySyncTextareaOnSubmit: true },
				function( textarea )
				{
					var editor = this;
					editor.dataProcessor.writer._.rules = {};
					editor.setData( 'foo bar' );
					jQuery('#submit').submit( function()
					{
						testSelf.resume( function()
						{
							assert.areSame( '<p>foo bar</p>', editor.getData(), '1' );
							assert.areSame( editor.getData(), jQuery( '#submit textarea' ).get( 0 ).value, '2' );
							testFinished = true;
							cleanup( 'submit_textarea' );
						});
						return false;
					});
					setTimeout(function()
					{
						jQuery( '#submit' ).submit();
					}, 1000 );
				}
			);
			testSelf.wait( function() {
				cleanup( 'submit_textarea' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_ajax_submit : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery( '#ajax_submit textarea' ).ckeditor(
				{ jquerySyncTextareaOnSubmit: true },
				function( textarea )
				{
					var editor = this;
					editor.dataProcessor.writer._.rules = {};
					editor.setData( 'foo bar' );
					jQuery('#ajax_submit').ajaxForm(
					{
						beforeSubmit: function( formData )
						{
							testSelf.resume( function()
							{
								assert.areSame( '<p>foo bar</p>', editor.getData(), '1' );
								assert.areSame( editor.getData(), formData[ 0 ][ 'value' ], '2' );
								testFinished = true;
								cleanup( 'ajax_submit_textarea' );
							});
							return false;
						}
					});
					setTimeout(function()
					{
						jQuery('#ajax_submit').submit();
					}, 1000 );
				});
			testSelf.wait(function(){
				cleanup( 'ajax_submit_textarea' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_global_event : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery( document ).bind( 'instanceReady.ckeditor', function( event, editor )
			{
				if ( !jQuery( event.target ).is( '#global_event' ) )
					return;
				jQuery( this ).unbind( 'instanceReady.ckeditor', arguments.callee );
				testSelf.resume( function()
				{
					assert.isTrue( editor instanceof CKEDITOR.editor, 'editor instanceof CKEDITOR.editor' );
					testFinished = true;
					cleanup( 'global_event' );
				});
			});
			jQuery( 'textarea#global_event' ).ckeditor();
			testSelf.wait( function(){
				cleanup( 'global_event' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout );
		},

		test_setData_event : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery( 'textarea#setData_event' )
				.one( 'setData.ckeditor', function( event, editor, data )
				{
					testSelf.resume( function()
					{
//								console.log('test_setData_event', data, editor.getData());
						assert.areSame( 'foo bar', data );
						assert.isTrue( editor instanceof CKEDITOR.editor, 'editor instanceof CKEDITOR.editor' );
						testFinished = true;
						cleanup( 'setData_event' );
					});
				})
				.ckeditor( function()
				{
					var editor = this;
					// Delay it a bit.
					setTimeout( function()
					{
						editor.setData('foo bar');
					}, 300 );
				});
//					testSelf.wait();
			testSelf.wait( function() {
				cleanup( 'setData_event' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_div_replace : function()
		{
			var testSelf = this,
				testFinished = false;
			jQuery( '#div_replace' ).ckeditor( function() {
				var editor = this;
				testSelf.resume( function()
				{
					assert.isTrue( editor instanceof CKEDITOR.editor, 'editor instanceof CKEDITOR.editor' );
					testFinished = true;
					cleanup( 'div_replace' );
				});
			});
			testSelf.wait( function() {
				cleanup( 'div_replace' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_parallel_callbacks : function()
		{
			var testSelf = this,
				testFinished = false;

			var called = [ false, false ];
			function checkCalled()
			{
				if ( called[ 0 ] && called[ 1 ] )
				{
					testSelf.resume( function()
					{
						var editor = jQuery( '#parallel_callbacks' ).ckeditorGet();
						editor.dataProcessor.writer._.rules = {};
						var content = editor.getData();

						assert.isTrue( !!content.match( 'callback1' ), 'callback1' );
						assert.isTrue( !!content.match( 'callback2' ), 'callback2' );
						// TODO cleanup here causes checkSelectionChange and other timeouted events to fail!
						cleanup( 'parallel_callbacks' );
					});
				}
			}

			function callback1()
			{
				this.insertElement( CKEDITOR.dom.element.createFromHtml( '<p>callback1</p>' ) );
				called[ 0 ] = true;
				checkCalled();
			}

			function callback2()
			{
				this.insertElement( CKEDITOR.dom.element.createFromHtml( '<p>callback2</p>' ) );
				called[ 1 ] = true;
				checkCalled();
			}

			jQuery( '#parallel_callbacks' )
				.ckeditor( callback1 )
				.ckeditor( callback2 );

			testSelf.wait( function() {
				cleanup( 'parallel_callbacks' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		test_series_callbacks : function()
		{
			var testSelf = this,
				testFinished = false;

			function callback1( element )
			{
				this.insertElement( CKEDITOR.dom.element.createFromHtml( '<p>callback1</p>' ) );
				jQuery( element ).ckeditor( callback2 );
			}

			function callback2()
			{
				var editor = this;
				testSelf.resume( function()
				{
					editor.insertElement( CKEDITOR.dom.element.createFromHtml( '<p>callback2</p>' ) );

					// Assert.
					editor.dataProcessor.writer._.rules = {};
					var content = editor.getData();

					assert.isTrue( !!content.match( 'callback1' ), 'callback1' );
					assert.isTrue( !!content.match( 'callback2' ), 'callback2' );
					cleanup( 'series_callbacks' );
				} );
			}

			jQuery( '#series_callbacks' ).ckeditor( callback1 );

			testSelf.wait( function() {
				cleanup( 'series_callbacks' );
				assert.isTrue( testFinished, 'Test not finished.' );
			}, testTimeout);
		},

		name :document.title
	};
} )() );
	</script>
</head>
<body>
		<form>
			<textarea rows="10" cols="30" id="create">default</textarea>
			<textarea rows="10" cols="30" id="config">default</textarea>
			<textarea rows="10" cols="30" id="config_no_order">default</textarea>
			<textarea rows="10" cols="30" id="val_get_without_timeout">default</textarea>
			<textarea rows="10" cols="30" id="val_get_with_timeout">default</textarea>
			<textarea rows="10" cols="30" id="val_set_with_timeout">default</textarea>
			<textarea rows="10" cols="30" id="ckeditor_get">default</textarea>
			<textarea rows="10" cols="30" id="destroy">default</textarea>
			<input id="val_input_get" value="default" />
			<input id="val_input_set" value="default" />
			<textarea rows="10" cols="30" id="global_event">default</textarea>
			<textarea rows="10" cols="30" id="setData_event">default</textarea>
			<textarea rows="10" cols="30" id="parallel_callbacks">default</textarea>
			<textarea rows="10" cols="30" id="series_callbacks">default</textarea>
		</form>
		<form action="./" method="post" id="submit">
			<textarea rows="10" cols="30" name="submit_textarea" id="submit_textarea">default</textarea>
			<input type="submit" value="Submit" />
		</form>
		<form action="/" method="post" id="ajax_submit">
			<textarea rows="10" cols="30" name="ajax_submit_textarea" id="ajax_submit_textarea">default</textarea>
			<input type="submit" value="Submit" />
		</form>
		<div style="padding: 15px; background-color: lightblue;">
			<div id="div_replace" style="width: 200px; height: 300px; background-color: black;">default</div>
		</div>
</body>
</html>
