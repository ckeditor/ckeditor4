<style>
	/* Swap margin with padding to prevent moving autocomplete panel outside editor. */
	body {
		margin-left: 0px;
		padding-left: 350px;
	}
</style>

<h2>Classic editor</h2>
<div id="editor1" >
	<p>First line</p>
	<p class="filler">Filler</p>
	<p>Middle line</p>
	<p class="filler">Filler</p>
	<p>Last line</p>
</div>

<h2>Divarea editor</h2>
<div id="editor2" >
	<p>First line</p>
	<p class="filler">Filler</p>
	<p>Middle line</p>
	<p class="filler">Filler</p>
	<p>Last line</p>
</div>

<h2>Inline editor</h2>
<div id="editor3" contenteditable=true >
	<p>First line</p>
	<p class="filler">Filler</p>
	<p>Middle line</p>
	<p class="filler">Filler</p>
	<p>Last line</p>
</div>

<script>

	if( CKEDITOR.env.ie && CKEDITOR.env.version == 8 ) {
		bender.ignore();
	}

	var config = {
		width: 600,
		extraAllowedContent: 'p(filler)',
		on: {
			instanceReady: function( evt ) {
				new CKEDITOR.plugins.autocomplete( evt.editor, getTextTestCallback(), dataCallback );
			}
		}
	};

	// Add CSS here so it will be available inside iframe (classic) editor.
	CKEDITOR.addCss( 'p.filler { height: 900px; border: 1px solid red; }' );

	CKEDITOR.replace( 'editor1', config );
	CKEDITOR.replace( 'editor2', CKEDITOR.tools.extend( config, { extraPlugins: 'divarea' } ) );
	CKEDITOR.inline( 'editor3', config );

	function getTextTestCallback() {
		return function( range ) {
			return CKEDITOR.plugins.textMatch.match( range, matchCallback );
		};
	}

	function matchCallback( text, offset ) {
		var left = text.slice( 0, offset ),
			match = left.match( new RegExp( '@\\w*$' ) );

		if ( !match ) {
			return null;
		}

		return { start: match.index, end: offset };
	}

	function dataCallback( query, range, callback ) {
		var data = [
			{ id: 1, name: '@john' },
			{ id: 2, name: '@thomas' },
			{ id: 3, name: '@anna' },
			{ id: 4, name: '@cris' },
			{ id: 5, name: '@julia' }
		];

		callback(
			data.filter( function( item ) {
				return item.name.indexOf( query ) === 0;
			} )
		);
	}

</script>
