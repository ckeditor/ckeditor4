<style>
	body {
		padding-top: 150px;
		margin-left: 0px;
		padding-left: 330px;
	}

	#editable {
		position: absolute;
		width: 300px;
		left: 600px;
	}

	#editable img {
		width: 100px;
		height: 30px;
		vertical-align: text-bottom;
	}

	.marker {
		position: absolute;
		outline: 1px solid red;
		pointer-events: none;
	}

	#output {
		width: 250px;
	}

</style>

<textarea name="output" id="output" cols="30" rows="10" readonly="readonly"></textarea>

<div id="editor" contenteditable="true">
	<p>Some text.</p>
	<table border="1" cellspacing="1" cellpadding="1" style="width:250px">
		<tbody>
		<tr>
			<td>Cell</td>
			<td>Cell</td>
			<td>Cell</td>
		</tr>
		<tr>
			<td>Cell</td>
			<td>Cell</td>
			<td>Cell</td>
		</tr>
		<tr>
			<td>Cell</td>
			<td>Cell</td>
			<td>Cell</td>
		</tr>
		</tbody>
	</table>
	<pre>
		<code class="language-javascript">console.log( 'Hello World!' );</code>
	</pre>
</div>


<script>
	( function() {
		// IE 8 polyfill doesn't work when selecting block elements like widget. Also it's unsupported by table selection.
		if ( CKEDITOR.env.ie && CKEDITOR.env.version === 8 ) {
			bender.ignore()
		}

		CKEDITOR.replace( 'editor', {
			height: 500,
			on: {
				instanceReady: function() {
					var rectMarkers = [];

					var doc = CKEDITOR.document,
						editable = this.editable(),
						par = editable.findOne( 'p' ),
						rng = new CKEDITOR.dom.range( editable ),
						output = doc.getById( 'output' ),
						editor = this;

					rng.setStart( par.getParent(), par.getIndex() );
					rng.setEnd( par.getParent(), par.getIndex() + 1 );

					this.getSelection().selectRanges( [ rng ] );

					window.setInterval( function() {
						var ranges = editor.getSelection().getRanges(),
							rects = ranges && CKEDITOR.tools.array.reduce( ranges, function( total, current ) {
								return total.concat( current.getClientRects( true ) );
							}, [] );

						output.setValue( 'Selection rect\n---\nrectangle count: ' + ( rects ? rects.length : rects ) );

						removeRectangles();

						if ( !rng || !rects || !rects.length ) {
							return;
						}

						output.setValue( output.getValue() + '\nwidth:' + rects[ 0 ].width + '\nheight: ' + rects[ 0 ].height );
						output.setValue( output.getValue() + '\ntop:' + rects[ 0 ].top + '\nleft: ' + rects[ 0 ].left );

						for ( var i = 0; i < rects.length; i++ ) {
							drawRectangle( rects[ i ] );
						}
					}, 100 );

					function drawRectangle( rect ) {
						var rectMarker;
						if ( !rectMarker ) {
							rectMarker = doc.createElement( 'div' );
							rectMarker.addClass( 'marker' );
							doc.getBody().append( rectMarker );
						}

						rectMarker.setStyles( {
							top: rect.top + 'px',
							left: rect.left + 'px',
							height: rect.height + 'px',
							width: rect.width + 'px'
						} );

						rectMarkers.push( rectMarker );
					}

					function removeRectangles() {
						if ( rectMarkers.length ) {
							rectMarkers = CKEDITOR.tools.array.filter( rectMarkers, function( marker ) {
								marker.remove();
								return false;
							} );
						}
					}
				}
			}
		} );
	} )();

</script>
